/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.keymaster@4.0;

/**
 * Time in milliseconds since some arbitrary point in time.  Time must be monotonically increasing,
 * and a secure environment's notion of "current time" must not repeat until the Android device
 * reboots, or until at least 50 million years have elapsed (note that this requirement is satisfied
 * by setting the clock to zero during each boot, and then counting time accurately).
 */
typedef uint64_t Timestamp;

/**
 * A place to define any needed constants.
 */
enum Constants : uint32_t {
    AUTH_TOKEN_MAC_LENGTH = 32,
};

enum TagType : uint32_t {
    /** Invalid type, used to designate a tag as uninitialized. */
    INVALID = 0 << 28,
    /** Enumeration value. */
    ENUM = 1 << 28,
    /** Repeatable enumeration value. */
    ENUM_REP = 2 << 28,
    /** 32-bit unsigned integer. */
    UINT = 3 << 28,
    /** Repeatable 32-bit unsigned integer. */
    UINT_REP = 4 << 28,
    /** 64-bit unsigned integer. */
    ULONG = 5 << 28,
    /** 64-bit unsigned integer representing a date and time, in milliseconds since 1 Jan 1970. */
    DATE = 6 << 28,
    /** Boolean.  If a tag with this type is present, the value is "true".  If absent, "false". */
    BOOL = 7 << 28,
    /** Byte string containing an arbitrary-length integer, big-endian ordering. */
    BIGNUM = 8 << 28,
    /** Byte string */
    BYTES = 9 << 28,
    /** Repeatable 64-bit unsigned integer */
    ULONG_REP = 10 << 28,
};

enum Tag : uint32_t {
    INVALID = TagType:INVALID | 0,

    /*
     * Tags that must be semantically enforced by hardware and software implementations.
     */

    /* Crypto parameters */
    PURPOSE = TagType:ENUM_REP | 1,    /* KeyPurpose. */
    ALGORITHM = TagType:ENUM | 2,      /* Algorithm. */
    KEY_SIZE = TagType:UINT | 3,       /* Key size in bits. */
    BLOCK_MODE = TagType:ENUM_REP | 4, /* BlockMode. */
    DIGEST = TagType:ENUM_REP | 5,     /* Digest. */
    PADDING = TagType:ENUM_REP | 6,    /* PaddingMode. */
    CALLER_NONCE = TagType:BOOL | 7,   /* Allow caller to specify nonce or IV. */
    MIN_MAC_LENGTH = TagType:UINT | 8, /* Minimum length of MAC or AEAD authentication tag in
                                        * bits. */
    // 9 reserved
    EC_CURVE = TagType:ENUM | 10,      /* EcCurve. */

    /* Algorithm-specific. */
    RSA_PUBLIC_EXPONENT = TagType:ULONG | 200,
    // 201 reserved for ECIES
    INCLUDE_UNIQUE_ID = TagType:BOOL | 202, /* If true, attestation certificates for this key must
                                             * contain an application-scoped and time-bounded
                                             * device-unique ID.*/

    /* Other hardware-enforced. */
    BLOB_USAGE_REQUIREMENTS = TagType:ENUM | 301, /* KeyBlobUsageRequirements. */
    BOOTLOADER_ONLY = TagType:BOOL | 302,         /* Usable only by bootloader. */
    ROLLBACK_RESISTANCE = TagType:BOOL | 303,     /* Whether key is rollback-resistant.  Specified
                                                   * in the key description provided to generateKey
                                                   * or importKey if rollback resistance is desired.
                                                   * If the implementation cannot provide rollback
                                                   * resistance, it must return
                                                   * ROLLBACK_RESISTANCE_UNAVAILABLE. */

    /* HARDWARE_TYPE specifies the type of the secure hardware that is requested for the key
     * generation / import.  See the SecurityLevel enum.  In the absence of this tag, keystore must
     * use TRUSTED_ENVIRONMENT.  If this tag is present and the requested hardware type is not
     * available, Keymaster returns HARDWARE_TYPE_UNAVAILABLE. This tag is not included in
     * attestations, but hardware type must be reflected in the Keymaster SecurityLevel of the
     * attestation header. */
    HARDWARE_TYPE = TagType:ENUM | 304,

    /*
     * Tags that should be semantically enforced by hardware if possible and will otherwise be
     * enforced by software (keystore).
     */

    /* Key validity period */
    ACTIVE_DATETIME = TagType:DATE | 400,             /* Start of validity. */
    ORIGINATION_EXPIRE_DATETIME = TagType:DATE | 401, /* Date when new "messages" should no longer
                                                       * be created. */
    USAGE_EXPIRE_DATETIME = TagType:DATE | 402,       /* Date when existing "messages" should no
                                                       * longer be trusted. */
    MIN_SECONDS_BETWEEN_OPS = TagType:UINT | 403,     /* Minimum elapsed time between
                                                       * cryptographic operations with the key. */
    MAX_USES_PER_BOOT = TagType:UINT | 404,           /* Number of times the key can be used per
                                                       * boot. */

    /* User authentication */
    // 500 reserved
    USER_ID = TagType:UINT | 501,             /* Android ID of authorized user or authenticator(s), */
    USER_SECURE_ID = TagType:ULONG_REP | 502, /* Secure ID of authorized user or authenticator(s).
                                               * Disallowed if NO_AUTH_REQUIRED is present. */
    NO_AUTH_REQUIRED = TagType:BOOL | 503,    /* If key is usable without authentication. */
    USER_AUTH_TYPE = TagType:ENUM | 504,      /* Bitmask of authenticator types allowed when
                                               * USER_SECURE_ID contains a secure user ID, rather
                                               * than a secure authenticator ID.  Defined in
                                               * HardwareAuthenticatorType. */
    AUTH_TIMEOUT = TagType:UINT | 505,        /* Required freshness of user authentication for
                                               * private/secret key operations, in seconds.  Public
                                               * key operations require no authentication.  If
                                               * absent, authentication is required for every use.
                                               * Authentication state is lost when the device is
                                               * powered off. */
    ALLOW_WHILE_ON_BODY =  TagType:BOOL | 506, /* Allow key to be used after authentication timeout
                                                * if device is still on-body (requires secure
                                                * on-body sensor. */

    /**
     * TRUSTED_USER_PRESENCE_REQUIRED is an optional feature that specifies that this key must be
     * unusable except when the user has provided proof of physical presence.  Proof of physical
     * presence must be a signal that cannot be triggered by an attacker who doesn't have one of:
     *
     *    a) Physical control of the device or
     *
     *    b) Control of the secure environment that holds the key.
     *
     * For instance, proof of user identity may be considered proof of presence if it meets the
     * requirements.  However, proof of identity established in one security domain (e.g. TEE) does
     * not constitute proof of presence in another security domain (e.g. StrongBox), and no
     * mechanism analogous to the authentication token is defined for communicating proof of
     * presence across security domains.
     *
     * Some examples:
     *
     *     A hardware button hardwired to a pin on a StrongBox device in such a way that nothing
     *     other than a button press can trigger the signal constitutes proof of physical presence
     *     for StrongBox keys.
     *
     *     Fingerprint authentication provides proof of presence (and identity) for TEE keys if the
     *     TEE has exclusive control of the fingerprint scanner and performs fingerprint matching.
     *
     *     Password authentication does not provide proof of presence to either TEE or StrongBox,
     *     even if TEE or StrongBox does the password matching, because password input is handled by
     *     the non-secure world, which means an attacker who has compromised Android can spoof
     *     password authentication.
     *
     * Note that no mechanism is defined for delivering proof of presence to Keymaster,
     * except perhaps as implied by an auth token.  This means that Keymaster must be able to check
     * proof of presence some other way.  Further, the proof of presence must be performed between
     * begin() and the first call to update() or finish().  If the first update() or the finish()
     * call is made without proof of presence, the keymaster method must return
     * ErrorCode::PROOF_OF_PRESENCE_REQUIRED and abort the operation.  The caller must delay the
     * update() or finish() call until proof of presence has been provided, which means the caller
     * must also have some mechanism for verifying that the proof has been provided.
     *
     * Only one operation requiring TUP may be in flight at a time.  If begin() has already been
     * called on one key with TRUSTED_USER_PRESENCE_REQUIRED, and another begin() comes in for that
     * key or another with TRUSTED_USER_PRESENCE_REQUIRED, Keymaster must return
     * ErrorCode::CONCURRENT_PROOF_OF_PRESENCE_REQUESTED.
     */
    TRUSTED_USER_PRESENCE_REQUIRED = TagType:BOOL | 507,

    /** TRUSTED_CONFIRMATION_REQUIRED is only applicable to keys with KeyPurpose SIGN, and specifies
     *  that this key must not be usable unless the user provides confirmation of the data to be
     *  signed. Confirmation is proven to keymaster via an approval token. See CONFIRMATION_TOKEN,
     *  as well as the ConfirmatinUI HAL.
     *
     * If an attempt to use a key with this tag does not have a cryptographically valid
     * CONFIRMATION_TOKEN provided to finish() or if the data provided to update()/finish() does not
     * match the data described in the token, keymaster must return NO_USER_CONFIRMATION. */
    TRUSTED_CONFIRMATION_REQUIRED = TagType:BOOL | 508,

    UNLOCKED_DEVICE_REQUIRED = TagType:BOOL | 509, /* Require the device screen to be unlocked if
                                                    * the key is used. */

    /* Application access control */
    APPLICATION_ID = TagType:BYTES | 601, /* Byte string identifying the authorized application. */

    /*
     * Semantically unenforceable tags, either because they have no specific meaning or because
     * they're informational only.
     */
    APPLICATION_DATA = TagType:BYTES | 700, /* Data provided by authorized application. */
    CREATION_DATETIME = TagType:DATE | 701, /* Key creation time */
    ORIGIN = TagType:ENUM | 702,            /* keymaster_key_origin_t. */
    // 703 is unused.
    ROOT_OF_TRUST = TagType:BYTES | 704,         /* Root of trust ID. */
    OS_VERSION = TagType:UINT | 705,             /* Version of system (keymaster2) */
    OS_PATCHLEVEL = TagType:UINT | 706,          /* Patch level of system (keymaster2) */
    UNIQUE_ID = TagType:BYTES | 707,             /* Used to provide unique ID in attestation */
    ATTESTATION_CHALLENGE = TagType:BYTES | 708, /* Used to provide challenge in attestation */
    ATTESTATION_APPLICATION_ID = TagType:BYTES | 709, /* Used to identify the set of possible
                                                       * applications of which one has initiated a
                                                       * key attestation */
    ATTESTATION_ID_BRAND = TagType:BYTES | 710,   /* Used to provide the device's brand name to be
                                                   * included in attestation */
    ATTESTATION_ID_DEVICE = TagType:BYTES | 711,  /* Used to provide the device's device name to
                                                   * be included in attestation */
    ATTESTATION_ID_PRODUCT = TagType:BYTES | 712, /* Used to provide the device's product name to
                                                   * be included in attestation */
    ATTESTATION_ID_SERIAL =
    TagType:BYTES | 713,                       /* Used to provide the device's serial number to be
                                                * included in attestation */
    ATTESTATION_ID_IMEI = TagType:BYTES | 714, /* Used to provide the device's IMEI to be included
                                                * in attestation */
    ATTESTATION_ID_MEID = TagType:BYTES | 715, /* Used to provide the device's MEID to be included
                                                * in attestation */
    ATTESTATION_ID_MANUFACTURER =
    TagType:BYTES | 716,                        /* Used to provide the device's manufacturer
                                                 * name to be included in attestation */
    ATTESTATION_ID_MODEL = TagType:BYTES | 717, /* Used to provide the device's model name to be
                                                 * included in attestation */

    /**
     * Patch level of vendor image.  The value is an integer of the form YYYYMM, where YYYY is the
     * four-digit year when the vendor image was released and MM is the two-digit month.  During
     * each boot, the bootloader must provide the patch level of the vendor image to keymaser
     * (mechanism is implemntation-defined).  When keymaster keys are created or updated, the
     * VENDOR_PATCHLEVEL tag must be cryptographically bound to the keys, with the current value as
     * provided by the bootloader.  When keys are used, keymaster must verify that the
     * VENDOR_PATCHLEVEL bound to the key matches the current value.  If they do not match,
     * keymaster must return ErrorCode::KEY_REQUIRES_UPGRADE.  The client must then call upgradeKey.
     */
    VENDOR_PATCHLEVEL = TagType:UINT | 718,

    /**
     * Patch level of boot image.  The value is an integer of the form YYYYMM, where YYYY is the
     * four-digit year when the boot image was released and MM is the two-digit month.  During each
     * boot, the bootloader must provide the patch level of the boot image to keymaser (mechanism is
     * implemntation-defined).  When keymaster keys are created or updated, the BOOT_PATCHLEVEL tag
     * must be cryptographically bound to the keys, with the current value as provided by the
     * bootloader.  When keys are used, keymaster must verify that the BOOT_PATCHLEVEL bound to the
     * key matches the current value.  If they do not match, keymaster must return
     * ErrorCode::KEY_REQUIRES_UPGRADE.  The client must then call upgradeKey.
     */
    BOOT_PATCHLEVEL = TagType:UINT | 719,

    /* Tags used only to provide data to or receive data from operations */
    ASSOCIATED_DATA = TagType:BYTES | 1000, /* Used to provide associated data for AEAD modes. */
    NONCE = TagType:BYTES | 1001,           /* Nonce or Initialization Vector */
    MAC_LENGTH = TagType:UINT | 1003,       /* MAC or AEAD authentication tag length in bits. */

    RESET_SINCE_ID_ROTATION = TagType:BOOL | 1004, /* Whether the device has beeen factory reset
                                                    * since the last unique ID rotation.  Used for
                                                    * key attestation. */

    /**
     * CONFIRMATION_TOKEN is used to deliver a cryptographic token proving that the user confirmed a
     * signing request. The content is a full-length HMAC-SHA256 value. See the ConfirmationUI HAL
     * for details of token computation.
     */
    CONFIRMATION_TOKEN = TagType:BYTES | 1005,
};

/**
 * Algorithms provided by keymaser implementations.
 */
enum Algorithm : uint32_t {
    /** Asymmetric algorithms. */
    RSA = 1,
    // DSA = 2, -- Removed, do not re-use value 2.
    EC = 3,

    /** Block ciphers algorithms */
    AES = 32,
    TRIPLE_DES = 33,

    /** MAC algorithms */
    HMAC = 128,
};

/**
 * Symmetric block cipher modes provided by keymaster implementations.
 */
enum BlockMode : uint32_t {
    /*
     * Unauthenticated modes, usable only for encryption/decryption and not generally recommended
     * except for compatibility with existing other protocols.
     */
    ECB = 1,
    CBC = 2,
    CTR = 3,

    /*
     * Authenticated modes, usable for encryption/decryption and signing/verification.  Recommended
     * over unauthenticated modes for all purposes.
     */
    GCM = 32,
};

/**
 * Padding modes that may be applied to plaintext for encryption operations.  This list includes
 * padding modes for both symmetric and asymmetric algorithms.  Note that implementations should not
 * provide all possible combinations of algorithm and padding, only the
 * cryptographically-appropriate pairs.
 */
enum PaddingMode : uint32_t {
    NONE = 1, /* deprecated */
    RSA_OAEP = 2,
    RSA_PSS = 3,
    RSA_PKCS1_1_5_ENCRYPT = 4,
    RSA_PKCS1_1_5_SIGN = 5,
    PKCS7 = 64,
};

/**
 * Digests provided by keymaster implementations.
 */
enum Digest : uint32_t {
    NONE = 0,
    MD5 = 1,
    SHA1 = 2,
    SHA_2_224 = 3,
    SHA_2_256 = 4,
    SHA_2_384 = 5,
    SHA_2_512 = 6,
};

/**
 * Supported EC curves, used in ECDSA
 */
enum EcCurve : uint32_t {
    P_224 = 0,
    P_256 = 1,
    P_384 = 2,
    P_521 = 3,
};

/**
 * The origin of a key (or pair), i.e. where it was generated.  Note that ORIGIN can be found in
 * either the hardware-enforced or software-enforced list for a key, indicating whether the key is
 * hardware or software-based.  Specifically, a key with GENERATED in the hardware-enforced list
 * must be guaranteed never to have existed outide the secure hardware.
 */
enum KeyOrigin : uint32_t {
    /** Generated in keymaster.  Should not exist outside the TEE. */
    GENERATED = 0,

    /** Derived inside keymaster.  Likely exists off-device. */
    DERIVED = 1,

    /** Imported into keymaster.  Existed as cleartext in Android. */
    IMPORTED = 2,

    /**
     * Keymaster did not record origin.  This value can only be seen on keys in a keymaster0
     * implementation.  The keymaster0 adapter uses this value to document the fact that it is
     * unkown whether the key was generated inside or imported into keymaster.
     */
    UNKNOWN = 3,

    /**
     * Securely imported into Keymaster.  Was created elsewhere, and passed securely through Android
     * to secure hardware.
     */
    SECURELY_IMPORTED = 4,
};

/**
 * Usability requirements of key blobs.  This defines what system functionality must be available
 * for the key to function.  For example, key "blobs" which are actually handles referencing
 * encrypted key material stored in the file system cannot be used until the file system is
 * available, and should have BLOB_REQUIRES_FILE_SYSTEM.
 */
enum KeyBlobUsageRequirements : uint32_t {
    STANDALONE = 0,
    REQUIRES_FILE_SYSTEM = 1,
};

/**
 * Possible purposes of a key (or pair).
 */
enum KeyPurpose : uint32_t {
    ENCRYPT = 0,    /* Usable with RSA, EC and AES keys. */
    DECRYPT = 1,    /* Usable with RSA, EC and AES keys. */
    SIGN = 2,       /* Usable with RSA, EC and HMAC keys. */
    VERIFY = 3,     /* Usable with RSA, EC and HMAC keys. */
    /* 4 is reserved */
    WRAP_KEY = 5,   /* Usable with wrapping keys. */
};

/**
 * Keymaster error codes.
 */
enum ErrorCode : int32_t {
    OK = 0,
    ROOT_OF_TRUST_ALREADY_SET = -1,
    UNSUPPORTED_PURPOSE = -2,
    INCOMPATIBLE_PURPOSE = -3,
    UNSUPPORTED_ALGORITHM = -4,
    INCOMPATIBLE_ALGORITHM = -5,
    UNSUPPORTED_KEY_SIZE = -6,
    UNSUPPORTED_BLOCK_MODE = -7,
    INCOMPATIBLE_BLOCK_MODE = -8,
    UNSUPPORTED_MAC_LENGTH = -9,
    UNSUPPORTED_PADDING_MODE = -10,
    INCOMPATIBLE_PADDING_MODE = -11,
    UNSUPPORTED_DIGEST = -12,
    INCOMPATIBLE_DIGEST = -13,
    INVALID_EXPIRATION_TIME = -14,
    INVALID_USER_ID = -15,
    INVALID_AUTHORIZATION_TIMEOUT = -16,
    UNSUPPORTED_KEY_FORMAT = -17,
    INCOMPATIBLE_KEY_FORMAT = -18,
    UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM = -19,   /** For PKCS8 & PKCS12 */
    UNSUPPORTED_KEY_VERIFICATION_ALGORITHM = -20, /** For PKCS8 & PKCS12 */
    INVALID_INPUT_LENGTH = -21,
    KEY_EXPORT_OPTIONS_INVALID = -22,
    DELEGATION_NOT_ALLOWED = -23,
    KEY_NOT_YET_VALID = -24,
    KEY_EXPIRED = -25,
    KEY_USER_NOT_AUTHENTICATED = -26,
    OUTPUT_PARAMETER_NULL = -27,
    INVALID_OPERATION_HANDLE = -28,
    INSUFFICIENT_BUFFER_SPACE = -29,
    VERIFICATION_FAILED = -30,
    TOO_MANY_OPERATIONS = -31,
    UNEXPECTED_NULL_POINTER = -32,
    INVALID_KEY_BLOB = -33,
    IMPORTED_KEY_NOT_ENCRYPTED = -34,
    IMPORTED_KEY_DECRYPTION_FAILED = -35,
    IMPORTED_KEY_NOT_SIGNED = -36,
    IMPORTED_KEY_VERIFICATION_FAILED = -37,
    INVALID_ARGUMENT = -38,
    UNSUPPORTED_TAG = -39,
    INVALID_TAG = -40,
    MEMORY_ALLOCATION_FAILED = -41,
    IMPORT_PARAMETER_MISMATCH = -44,
    SECURE_HW_ACCESS_DENIED = -45,
    OPERATION_CANCELLED = -46,
    CONCURRENT_ACCESS_CONFLICT = -47,
    SECURE_HW_BUSY = -48,
    SECURE_HW_COMMUNICATION_FAILED = -49,
    UNSUPPORTED_EC_FIELD = -50,
    MISSING_NONCE = -51,
    INVALID_NONCE = -52,
    MISSING_MAC_LENGTH = -53,
    KEY_RATE_LIMIT_EXCEEDED = -54,
    CALLER_NONCE_PROHIBITED = -55,
    KEY_MAX_OPS_EXCEEDED = -56,
    INVALID_MAC_LENGTH = -57,
    MISSING_MIN_MAC_LENGTH = -58,
    UNSUPPORTED_MIN_MAC_LENGTH = -59,
    UNSUPPORTED_KDF = -60,
    UNSUPPORTED_EC_CURVE = -61,
    KEY_REQUIRES_UPGRADE = -62,
    ATTESTATION_CHALLENGE_MISSING = -63,
    KEYMASTER_NOT_CONFIGURED = -64,
    ATTESTATION_APPLICATION_ID_MISSING = -65,
    CANNOT_ATTEST_IDS = -66,
    ROLLBACK_RESISTANCE_UNAVAILABLE = -67,
    HARDWARE_TYPE_UNAVAILABLE = -68,
    PROOF_OF_PRESENCE_REQUIRED = -69,
    CONCURRENT_PROOF_OF_PRESENCE_REQUESTED = -70,
    NO_USER_CONFIRMATION = -71,
    DEVICE_LOCKED = -72,

    UNIMPLEMENTED = -100,
    VERSION_MISMATCH = -101,

    UNKNOWN_ERROR = -1000,
};

/**
 * Key derivation functions, mostly used in ECIES.
 */
enum KeyDerivationFunction : uint32_t {
    /** Do not apply a key derivation function; use the raw agreed key */
    NONE = 0,
    /** HKDF defined in RFC 5869 with SHA256 */
    RFC5869_SHA256 = 1,
    /** KDF1 defined in ISO 18033-2 with SHA1 */
    ISO18033_2_KDF1_SHA1 = 2,
    /** KDF1 defined in ISO 18033-2 with SHA256 */
    ISO18033_2_KDF1_SHA256 = 3,
    /** KDF2 defined in ISO 18033-2 with SHA1 */
    ISO18033_2_KDF2_SHA1 = 4,
    /** KDF2 defined in ISO 18033-2 with SHA256 */
    ISO18033_2_KDF2_SHA256 = 5,
};

/**
 * Hardware authentication type, used by HardwareAuthTokens to specify the mechanism used to
 * authentiate the user, and in KeyCharacteristics to specify the allowable mechanisms for
 * authenticating to activate a key.
 */
enum HardwareAuthenticatorType : uint32_t {
    NONE = 0,
    PASSWORD = 1 << 0,
    FINGERPRINT = 1 << 1,
    // Additional entries must be powers of 2.
    ANY = 0xFFFFFFFF,
};

/**
 * Device security levels.
 */
enum SecurityLevel : uint32_t {
    SOFTWARE = 0,
    TRUSTED_ENVIRONMENT = 1,
    /**
     * STRONGBOX specifies that the secure hardware satisfies the following requirements:
     *
     *    a) Has a discrete CPU.  The StrongBox device must not be the same CPU that is used to run
     *       the Android non-secure world, or any other untrusted code.  The StrongBox CPU must not
     *       share cache, RAM or any other critical resources with any device that runs untrusted
     *       code.
     *
     *    b) Has integral secure storage.  The StrongBox device must have its own non-volatile
     *       storage that is not accessible by any other hardware component.
     *
     *    c) Has a high-quality True Random Number Generator.  The StrongBox device must have sole
     *       control of and access to a high-quality TRNG which it uses for generating necessary
     *       random bits.  It must combine the output of this TRNG with caller-provided entropy in a
     *       strong CPRNG, as do non-Strongbox Keymaster implementations.
     *
     *    d) Is enclosed in tamper-resistant packaging.  The StrongBox device must have
     *       tamper-resistant packaging which provides obstacles to physical penetration which are
     *       higher than those provided by normal integrated circuit packages.
     *
     *    e) Provides side-channel resistance.  The StrongBox device must implement resistance
     *       against common side-channel attacks, including power analysis, timing analysis, EM
     *       snooping, etc.
     *
     * Devices with StrongBox Keymasters must also have a non-StrongBox Keymaster, which lives in
     * the higher-performance TEE.  Keystore must load both StrongBox (if available) and
     * non-StrongBox HALs and route key generation/import requests appropriately.  Callers that want
     * StrongBox keys must add Tag::HARDWARE_TYPE with value SecurityLevel::STRONGBOX to the key
     * description provided to generateKey or importKey.  Keytore must route the request to a
     * StrongBox HAL (a HAL whose isStrongBox method returns true).  Keymaster implementations that
     * receive a request for a Tag::HARDWARE_TYPE that is inappropriate must fail with
     * ErrorCode::HARDWARE_TYPE_UNAVAILABLE.
     */
    STRONGBOX = 2,              /* See IKeymaster::isStrongBox */
};

/**
 * Formats for key import and export.
 */
enum KeyFormat : uint32_t {
    /** X.509 certificate format, for public key export. */
    X509 = 0,
    /** PCKS#8 format, asymmetric key pair import. */
    PKCS8 = 1,
    /** Raw bytes, for symmetric key import and export. */
    RAW = 3,
};

struct KeyParameter {
    /**
     * Discriminates the uinon/blob field used.  The blob cannot be coincided with the union, but
     * only one of "f" and "blob" is ever used at a time. */
    Tag tag;
    union IntegerParams {
        /** Enum types */
        Algorithm algorithm;
        BlockMode blockMode;
        PaddingMode paddingMode;
        Digest digest;
        EcCurve ecCurve;
        KeyOrigin origin;
        KeyBlobUsageRequirements keyBlobUsageRequirements;
        KeyPurpose purpose;
        KeyDerivationFunction keyDerivationFunction;
        HardwareAuthenticatorType hardwareAuthenticatorType;
        SecurityLevel hardwareType;

        /** Other types */
        bool boolValue;  // Always true, if a boolean tag is present.
        uint32_t integer;
        uint64_t longInteger;
        uint64_t dateTime;
    };
    IntegerParams f;  // Hidl does not support anonymous unions, so we have to name it.
    vec<uint8_t> blob;
};

struct KeyCharacteristics {
    vec<KeyParameter> softwareEnforced;
    vec<KeyParameter> hardwareEnforced;
};

/**
 * Data used to prove successful authentication.
 */
struct HardwareAuthToken {
    uint64_t challenge;
    uint64_t userId;             // Secure User ID, not Android user ID.
    uint64_t authenticatorId;    // Secure authenticator ID.
    HardwareAuthenticatorType authenticatorType;
    Timestamp timestamp;
    /**
     * MACs are computed with a backward-compatible method, used by Keymaster 3.0, Gatekeeper 1.0
     * and Fingerprint 1.0, as well as pre-treble HALs.
     *
     * The MAC is Constants::AUTH_TOKEN_MAC_LENGTH bytes in length and is computed as follows:
     *
     *     HMAC_SHA256(
     *         H, 0 || challenge || user_id || authenticator_id || authenticator_type || timestamp)
     *
     * where ``||'' represents concatenation, the leading zero is a single byte, and all integers
     * are represented as unsigned values, the full width of the type.  The challenge, userId and
     * authenticatorId values are in machine order, but authenticatorType and timestamp are in
     * network order.  This odd construction is compatible with the hw_auth_token_t structure,
     *
     * Note that mac is a vec rather than an array, not because it's actually variable-length but
     * because it could be empty.  As documented in the IKeymasterDevice::begin,
     * IKeymasterDevice::update and IKeymasterDevice::finish doc comments, an empty mac indicates
     * that this auth token is empty.
     */
    vec<uint8_t> mac;
};

typedef uint64_t OperationHandle;

/**
 * HmacSharingParameters holds the data used in the process of establishing a shared HMAC key
 * between multiple Keymaster instances.  Sharing parameters are returned in this struct by
 * getHmacSharingParameters() and send to computeSharedHmac().  See the named methods in IKeymaster
 * for details of usage.
 */
struct HmacSharingParameters {
    /**
     * Either empty or contains a persistent value that is associated with the pre-shared HMAC
     * agreement key (see documentation of computeSharedHmac in @4.0::IKeymaster).  It is either
     * empty or 32 bytes in length.
     */
    vec<uint8_t> seed;

    /**
     * A 32-byte value which is guaranteed to be different each time
     * getHmacSharingParameters() is called.  Probabilistic uniqueness (i.e. random) is acceptable,
     * though a stronger uniqueness guarantee (e.g. counter) is recommended where possible.
     */
    uint8_t[32] nonce;
};

/**
 * VerificationToken enables one Keymaster instance to validate authorizations for another.  See
 * verifyAuthorizations() in IKeymaster for details.
 */
struct VerificationToken {
    /**
     * The operation handle, used to ensure freshness.
     */
    uint64_t challenge;

    /**
     * The current time of the secure environment that generates the VerificationToken.  This can be
     * checked against auth tokens generated by the same secure environment, which avoids needing to
     * synchronize clocks.
     */
    Timestamp timestamp;

    /**
     * A list of the parameters verified.  Empty if the only parameters verified are time-related.
     * In that case the timestamp is the payload.
     */
    vec<KeyParameter> parametersVerified;

    /**
     * SecurityLevel of the secure environment that generated the token.
     */
    SecurityLevel securityLevel;

    /**
     * 32-byte HMAC-SHA256 of the above values, computed as:
     *
     *    HMAC(H,
     *         "Auth Verification" || challenge || timestamp || securityLevel || parametersVerified)
     *
     * where:
     *
     *   ``HMAC'' is the shared HMAC key (see computeSharedHmac() in IKeymaster).
     *
     *   ``||'' represents concatenation
     *
     * The representation of challenge and timestamp is as 64-bit unsigned integers in big-endian
     * order.  securityLevel is represented as a 32-bit unsigned integer in big-endian order.
     *
     * If parametersVerified is non-empty, the representation of parametersVerified is an ASN.1 DER
     * encoded representation of the values.  The ASN.1 schema used is the AuthorizationList schema
     * from the Keystore attestation documentation.  If parametersVerified is empty, it is simply
     * omitted from the HMAC computation.
     */
    vec<uint8_t> mac;
};
